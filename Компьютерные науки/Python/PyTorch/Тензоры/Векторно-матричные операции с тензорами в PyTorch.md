## Матричное произведение
Чтобы выполнить [[Матрицы|матричное произведение]] можно использовать одну из следующих функций (методов): **matmul()** и **mm()**. Отличие между ними в том, что **matmul()** выполняет матричное умножение с возможность [[Транслирование тензоров. Согласованные тензоры|транслирования]], а **mm()** - без возможности транслирования. Рассмотрим на примере:
```Python
#tensor([[ 2.,  4.,  6.],
#       [ 8., 10., 12.],
#       [14., 16., 18.]])
a = torch.linspace(2, 18, 9).view(3, 3)
# tensor([[ 2.,  4.],
#       [ 6.,  8.],
#       [10., 12.]])
b = torch.linspace(2, 12, 6).view(3, 2)
# tensor([[ 88.,  112.],
#       [ 196.,  256.],
#       [304., 400.]])
print(torch.matmul(a, b))
# tensor([[ 88.,  112.],
#       [ 196.,  256.],
#       [304., 400.]])
print(torch.mm(a, b))
# tensor([[ 88.,  112.],
#       [ 196.,  256.],
#       [304., 400.]])
print(a.matmul(b))
# tensor([[ 88.,  112.],
#       [ 196.,  256.],
#       [304., 400.]])
print(a.mm(b))
```
Разница между **matmul()** и **mm()**:
```Python
```Python
# tensor([[ 2,  4,  6],
#         [ 8, 10, 12],
#         [14, 16, 18]], dtype=torch.int32)
a = torch.linspace(2, 18, 9, dtype=torch.int32).view(3, 3)
# tensor([-1, -2, -3], dtype=torch.int32)
v = torch.IntTensor([-1, -2, -3])
print(torch.matmul(v, a)) # tensor([-60, -72, -84], dtype=torch.int32)
print(torch.matmul(a, v)) # tensor([-28, -64, -100], dtype=torch.int32)
print(torch.mm(v, a)) # Ошибка!
print(torch.mm(a, v)) # Ошибка!
```

Также в PyTorch есть возможность перемножения [[Матрицы|матриц]] пакетами (батчами) с помощью функции (метода) **bmm()**. То есть набор n матриц размерностью a\*b умножается на набор n матриц размерность b\*c и получается набор n матриц размерностью a\*c, полученных при помощи матричных произведений.
```Python
bx = torch.randn(7, 3, 4)
by = torch.randn(7, 4, 5)
bc = torch.bmm(bx, by)
print(bc.size()) # torch.Size([7, 3, 5])
```
## Векторные операции
Рассмотрим следующие векторные операции: скалярное произведение вектора-строки на вектор-столбец и внешнее произведение вектора-столбца на вектор-строку. Первое осуществляется при помощи функции (метода) **dot()**, а второе при помощи фукции (метода) **outer()**. Рассмотрим на примере:
```Python
a = torch.arange(1, 10, dtype=torch.float32)
b = torch.ones(9)
# Скалярное произведение
c = torch.dot(a) # tensor([45.])
c = a.dot(b) # tensor([45.])
# Внешнее произведение
c = torch.outer(a, b)
c = a.outer(b)
```
### Умножение вектора на [[Матрицы|матрицу]]
1) **Умножение вектора-столбца на матрицу.** Результатом операции будет вектор-строка (используется функция (метод) **mv()**, где первый аргумент - тензор-матрица, а второй аргумент - вектор-столбец).
```Python
m = torch.arange(1, 13, 1, dtype=torch.float32).view(3, 4)
v = torch.FloatTensor([1, 2, 3, 4])
print(torch.mv(m, v)) # tensor([ 30.,  70., 110.])
print(m.mv(v)) # tensor([ 30.,  70., 110.])
```
2) **Умножение матрицы на вектор-столбец.** Резульатом операции будет вектор-столбец (функция (метод) **matmul()** или его аналог оператор @).
```Python
m = torch.arange(1, 13, 1, dtype=torch.float32).view(4, 3)
v = torch.FloatTensor([1, 2, 3, 4])
print(torch.matmul(v, m)) # tensor([70., 80., 90.])
print(v @ m) # tensor([70., 80., 90.])
```
## Решение СЛАУ
Пример:
$$
\begin{cases}
1x_{1} + 2x_{2} + 3x_{3} = y_{1} \\
1x_{1} + 4x_{2} + 9x_{3} = y_{2} \\
1x_{1} + 8x_{2} + 27x_{3} = y_{3}
\end{cases}
$$
Чтобы решить СЛАУ мы можем воспользоваться двумя основными способами:
1) Используя функцию **slove()** из модуля linalg пакета torch.
```Python
A = FloatTensor([(1, 2, 3), (1, 4, 9), (1, 8, 27)]) # Матрица коэффициентов
Y = FloatTensor([10, 20, 30]) # Вектор значений
print(torch.linalg.matrix_rank(A)) # Вычисление ранга матрицы
X = torch.linalg.solve(A, Y) # tensor([-5.0000, 10.0000, -1.6667])
```
2) Решая матричное уравнение $X^{T} = A^{-1}Y^{T}$.
```Python
A = FloatTensor([(1, 2, 3), (1, 4, 9), (1, 8, 27)]) # Матрица коэффициентов
Y = FloatTensor([10, 20, 30]) # Вектор значений
print(torch.linalg.matrix_rank(A)) # Вычисление ранга матрицы
invA = torch.linalg.inv(A) # Нахождение обратной матрицы
X = torch.mv(invA, Y) # tensor([-5.0000, 10.0000, -1.6667])
```

#CS #Python #PyTorch #Тензоры 