**Основные типы данных в PyTorch:**
![[Основные типы данных в PyTorch.png]]
В PyTorch тензор может хранить в себе только один тип данных. По умолчанию в нем хранятся данные типа *torch.float32* или же *torch.int64*, но если требуется хранить другой тип данных, то это можно явно указать:
```Python
t = torch.empty(3, 5, 2, dtype=torch.int32)
```

Рассмотрим основные способы создания тензора в PyTorch:
```Python
# Старый способ создания тензора (не рекомендуется)
t = torch.Tensor(3, 5, 2) # Размерность 3x5x2

# Современные способы создания тензора
t = torch.empty(3, 5, 2) # Инициализируется машинным "мусором"

t = torch.zeros(2, 3) # Инициализируется нулями

t = torch.ones(2, 3) # Инициализируется единицами

t = torch.eye(3) # Создание единичной матрицы 3x3
t = torch.eye(3, 2) # Создание единичной матрицы 3x2

t = torch.full((2, 4), 5) # Создание тензора размерностью 2x4, инициализируемым пятерками
```

Способы создания тензоров различного типа данных:
![[Создание тензоров с определенным типом данных (старый способ).png]]

Если нужно создать тензор со строго определенным набором данных, то рекомендуется применять метод *tensor()*:
```Python
t = torch.tensor([1]) # 0-мерный тензор, целочисленный тип данных
t = torch.tensor([1.0, 2, 3, 4]) # 1-мерный тензор, вещественный тип данных
t = torch.tensor([[1, 2], [3, 4], [5, 6]]) # 2-мерный тензор
t = torch.tensor([3], dtype=torch.float32) # 0-мерный тензор, вещественный тип данных
```

Если требуется создать в тензоре арифметическую прогрессию, то есть два способа: методы *arange()* и *linspace()*. Первый метод создает арифметическую прогрессию от n к m, не включая конец, с шагом step, который, если не указать, будет равен единице. Второй метод разбивает отрезок \[n; m\] на k равноудаленных чисел, включая конец.
```Python
# Арифметическая прогрессия в тензоре
t = torch.arange(7) # tensor([0, 1, 2, 3, 4, 5, 6])
t = torch.arange(-5, 0) # tensor([-5, -4, -3, -2, -1])
t = torch.arange(-5, 0, 2) # tensor([-5, -3, -1])
t = torch.arange(1, 0, -0.2) # tensor([1.0000, 0.8000, 0.6000, 0.4000, 0.2000])

# Разбиение отрезка на равноудаленные числа
t = torch.linspace(1, 5, 2) # tensor([1., 5.])
t = torch.linspace(1, 5, 1) # tensor([1.])
t = torch.linspace(1, 5, 0) # tensor([])
t = torch.linspace(1, 5, 3) # tensor([1., 2., 5.])
t = torch.linspace(1, 5, 4) # tensor([1.0000, 2.3333, 3.6667, 5.0000])
```

Рассмотрим способы создания тензоров, инициализированных псевдослучайными величинами:
```Python
torch.rand(2, 3) # Инициализация тензора 2x3 равномерно распределенными псевдослучайными величинами из интервала [0, 1)
torch.randn(2, 3) # Инициализация тензора 2x3 псевдослучайными нормально распределенными величинами с нулевым средним и единичной дисперсией
```
Чтобы при запуске программы всегда генерировались одни и те же псевдослучайные числа, нужно зафиксировать seed, это делается с помощью функции *torch.manual_seed()*:
```Python
torch.manual_seed(12)
torch.rand(2, 3) # Всегда одна и та же инициализация
torch.randn(2, 3) # Всегда одна и та же инициализация
```

Рассмотрим основные свойства и методы, возвращающие характеристики тензора:
```Python
d = [[[1, 2, 3], [4, 5, 6]]]
t = torch.tensor(d, dtype=torch.float32)

print(t.type()) # Возвращает класс тензора, на основе которого он сформирован
print(t.dtype) # Возвращает тип данных, который хранит тензор
print(t.dim()) # Возвращает количество осей тензора
print(t.size()) # Возвращает количество элементов на каждой оси
print(t.shape) # То же самое, что и t.size()
print(t.mT) # Возвращает транспонированный тензор
```

#CS #Python #PyTorch #Тензоры 