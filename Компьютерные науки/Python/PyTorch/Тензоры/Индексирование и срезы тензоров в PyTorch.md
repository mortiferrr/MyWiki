## Одномерные тензоры
Индексация элементов [[Создание и устройство тензоров в PyTorch|тензора]] в PyTorch начинается с нуля (первый элемент). Рассмотрим, как обращаться к элемента тензор по индексу:
```Python
t = torch.arange(12) # tensor(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
print(t[2]) # tensor(2), то есть возвращается 0-мерный тензор с элементов с индексом 2
print(t[2].item()) # 2, то есть вернется числовое представление элемента с индексом 2
```
Также в тензорах PyTorch можно выполнять индексацию с помощью отрицательных чисел. В этом случае индексация начинается с индекса -1, который ссылается на последний элемент тензора:
```Python
t = torch.arange(12) # tensor(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
print(t[-1]) # tensor(11)
print(t[-1].item()) # 11
print(t[-2].item()) # 10
```
Чтобы изменить значение элемента, нужно обратиться к этому элементу по индексу и выполнить операцию присваивания:
```Python
t = torch.arange(12)
t[0] = 100 # Изменяем первый элемент с 0 на 100
t[-1] = -100 # Изменяем последний элемент с 11 на -100
print(t) # tensor(100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -100)
```

Работа со срезами тензоров PyTorch схожа со срезами обычных списков Python. В общем случае срез выглядит так: *<имя_тензора>\[start:end:step\]* - где по умолчанию шаг равен единице, если его явно не указать; элемент с индексом *end* не включается в срез; любой из аргументов среза может быть пропущен (могут быть пропущены даже все аргументы, в этом случае будет получен изначальный тензор), но все двоеточия должны присутствовать в любом случае (за исключением двух случаев, которые рассмотрены в ниже). 
Созданный срез, ссылается на ту же самую память, что и эти же элементы оригинального тензора, то есть не происходит копирования и работа осуществляется с теми же самыми данными. Рассмотрим на примере, как выполняются срезы тензора:
```Python
t = torch.arange(12) # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])

# Срез от индекса 0 до индекса 4 (не включая) с шагом 1
print(t[0:4]) # tensor([0, 1, 2, 3])
# Срез от индекса 0 до индекса 4 (не включая) с шагом 2
print(t[0:4:2]) # tensor([0, 2])
# Срез от индекса 5 до конца тензора (включая конец) с шагом 1
print(t[5::]) # tensor([5, 6, 7, 8, 9, 10, 11])
# Срез до индекса 5 (не включая) с шагом 1
print(t[:5]) # tensor([0, 1, 2, 3, 4])
print(t[:5:]) # tensor([0, 1, 2, 3, 4])
# Срез от начала тензора до индекса 6 (не включая) с шагом 2
print(t[:6:2]) # tensor([0, 2, 4])
# Срез от начала до конца тензора (включая конец) с шагом 4
print(t[::4]) # tensor([0, 4, 8])
# Срез от 6 индекса до конца тензора (включая конец) с шагом 3
print(t[6::3]) # tensor([6, 9])
# Срез от начала и до конца включительно
print(t[::]) # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
print(t[:]) # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
print(t[...]) # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
```
**Примечание:** В срезах можно указывать также отрицательные индексы, в том числе можно смешивать и отрицательный, и положительный индекс в одном и том же срезе. Шаг отрицательным быть не может.

Также можно задать срезу определенный набор значений. Работает для всех видов срезов, важно лишь учитывать количество элементов, которые мы передает срезу (оно должно равняться длине среза). Рассмотрим как это делать:
```Python
t = torch.arange(12)
t[:5] = torch.tensor([0, -1, -2, -3, -4])
print(t) # tensor([0, -1, -2, -3, -4, 5, 6, 7, 8, 9, 10, 11])
```

## Многомерные тензоры
Индексация многомерных [[Создание и устройство тензоров в PyTorch|тензоров]] во многом схожа с индексацией одномерных тензоров. Индексы многомерных тензоров указываются также в квадратных скобках и через запятую, разберем на примере:
```Python
t = torch.IntTensor([(1, 2, 3), (10, 20, 30), (100, 200, 300)])
print(t[1, 2]) # tensor(6, dtype=torch.int32)
print(t[1, 2].item()) # 6

t = torch.arange(24).view(2, 3, 2, 2)
print(t[1, 2, 0, 1]) # tensor(21)
print(t[1, 2, 0, 1].item()) # 21
```

Срезы в многомерных тензорах анологичны срезам в одномерных тензорах, они также пишутся в квадратных скобках и указываются через запятую, разберем на примере:
**Двумерный тензор ([[Матрицы|матрица]]):**
```Python
t = torch.IntTensor([(1, 2, 3), (10, 20, 30), (100, 200, 300)])
# Срез первой строки матриц
print(t[0]) # tensor([1, 2, 3], dtype=torch.int32)
print(t[0, :]) # tensor([1, 2, 3], dtype=torch.int32)
print(t[0, ...]) # tensor([1, 2, 3], dtype=torch.int32)
# Срез второго столбца матрицы
print(t[:, 1])
print(t[..., 1])
# Срез второго элемента в первом и втором столбцах
print(t[0:2, 1]) # tensor([2, 20], dtype=torch.int32)
# Срез второго и третьего элементов в первой строке
print(t[0, 1:3]) # tensor([2, 3], dtype=torch.int32)
# Срез первого и второго элементов во второй и третьей строках
print(t[1:, 0:2]) # tensor([[ 10,  20], [100, 200]], dtype=torch.int32)

# Аналогично работает и с другими вариациями срезов
```
**Многомерный тензор:**
```Python
t = torch.arange(24).view(2, 3, 2, 2)

print(t[0]) # Срез первого элемента первой оси тензора
print(t[0, ...]) # Срез первого элемента первой оси тензора
print(t[0, :, :, :]) # Срез первого элемента первой оси тензора
print(t[0, 2]) # Срез в первом элементе первой оси третьих элементов второй оси
print(t[0, 2, ...]) # Срез в первом элементе первой оси третьих элементов второй оси
print(t[0, 2, :, :]) # Срез в первом элементе первой оси третьих элементов второй оси
print(t[1, :, 1, :]) # Срез во втором элементе первой оси вторых элементов третьей оси
# Аналогично работает и с другими вариациями срезов

print(t[..., 1]) # Срез 2 элемента во всех осях
print(t[:, :, :, 1]) # Срез 2 элемента во всех осях
# Аналогично работает и с другими вариациями срезов
```
## Списочная индексация
В качестве индекса при индексировании [[Создание и устройство тензоров в PyTorch|тензора]] мы можем передать не число, а список, или даже тензор. В этом случае, во-первых, создается копия тензора, соответственно новый тензор не будет оказывать влияния на старый, во-вторых, новый тензор получается в результате взятия элементов из старого тензора с индексами, который прописаны в списке (тензоре), переданном в качестве индекса. Рассмотрим на примере:
```Python
t = torch.arange(1, 9) # tensor([1, 2, 3, 4, 5, 6, 7, 8])
print(t[[0]]) # tensor([1])

# !Создаем! 0-мерный тензор с первым элементом из тензора t
b = t[[0]]
# Меняем значение 0-мерного тензора
b[0] = 10
# Видим, что изменение в тензоре b не повлияло на тензор t
print(b) # tensor([10])
print(t) # tensor([1, 2, 3, 4, 5, 6, 7, 8])

# Создаем одномерный тензор с элементами из тензора t, имеющими индекс 0, 1, 7, 5
b = t[[0, 1, 7, 5]] 
print(b) # tensor([1, 2, 8, 6])

# Создаем одномерный тензор с элементами из тензора t, имеющими индекс 0, 1, 7, 5
# Разница в том, что учитывается дублирование индексов
b = t[[0, 0, 1, 1, 1, 2, 3, 4, 5, 6, 7]]
print(b) # tensor([1, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8])

# Срезы в списочной индекcации недопустимы
```
Также в качестве индекса можно передать список (тензор), который содержит булевые значения. В этом случае вернется тензор, содержащий себе элементы, индексы в старом тензоре которых совпадали с тем же индексом в булевом списке (тензоре) со значением True. Количество элементов в булевом списке (тензоре) должно совпадать с количеством элемента тензора, из которого мы хотим взять элементы.
```Python
t = torch.arange(1, 9) # tensor([1, 2, 3, 4, 5, 6, 7, 8])
b_ten = torch.BoolTensor([True, True, False, False, False, True, False, False])
b_list = [True, True, False, False, False, True, False, False]
print(t[b_ten]) # tensor([1, 2, 6])
print(t[b_list]) # tensor([1, 2, 6])

# Чтобы получить булевый тензор можно поступить следующим образом
i = a > 5
# Вернулся булевый тензор, содержаший True на тех индексах, на которых в тензоре # a элементы соответствуют условию
print(i) # tensor([False, False, False, False, False, True, True, True])
print(a[i]) # tensor([6, 7, 8])

# Чтобы объединить приведенные выше операции можно поступить следующим образом
print(a[a > 5]) # tensor([6, 7, 8])
```
**Примечание:** Списочная индексация многомерных массивах выполняется идентично, только списки (тензоры) передаются через запятую.

#CS #Python #PyTorch #Тензоры 