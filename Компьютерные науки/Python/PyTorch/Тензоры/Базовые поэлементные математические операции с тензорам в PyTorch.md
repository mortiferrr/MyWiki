**Основные поэлементные математические операции с [[Создание и устройство тензоров в PyTorch|тензорами]]:**
![[Базовые математические операции с тензорами в PyTorch.png]]
**Примечание:** Приоритеты приведенных на картинке математический операций точно такие же, как и в языке Python.

Эквивалентные способы применения математический операций (приведены основные способы, с остальными можно ознакомиться в документации):![[Сокращенные мат.операции с тензорами.png]]
![[Мат.операции с тензорами в виде методов и функций.png]]
## Поэлементные математические операции с одним тензором
```Python
t = torch.FloatTensor([1, 2, 3])

print(t - 3) # tensor([-2., -1., 0.])
print(-t) # tensor([-1., -2., -3.])
print(t + 2) # tensor([3., 4., 5.])
print(+t) # tensor([1., 2., 3.])
print(t * 2) # tensor([2., 4., 6.])
print(t / 4) # tensor([0.2500, 0.5000, 0.7500])
print((t + 10) // 4) # tensor([2., 3., 3.])
print(t**3) # tensor([1., 8., 27.])
print((t + 13) % 5) # tensor([4., 0., 1.])
```
**Примечание:** С многомерным тензором математические операции выполняются абсолютно идентично.
## Поэлементные математические операции с несколькими тензорами
Поэлементные математические операции можно выполнять **только с [[Транслирование тензоров. Согласованные тензоры|согласованными тензорами]]!**
```Python
a = torch.IntTensor([1, 7, 3]) # 1x3
b = torch.FloatTensor([9, 3, 5]) # 1x3
с = torch.FloatTensor([-9, -3, -5]) # 1x3

print(a + b) # tensor([10., 10.,  8.])
print(a - b) # tensor([-8., 4.,  -2.])
print(a * b) # tensor([9., 21.,  15.])
print(a / b) # tensor([0.1111, 2.3333,  0.6000])
print(a // b) # tensor([0., 2.,  0.])
print(a % b) # tensor([1., 1.,  3.])
print(a ** b) # tensor([1., 343.,  243.])
print(a ** b - a + 10**2) # tensor([100., 436.,  340.])

# Обычное сложение
print(a.add(b)) # tensor([10., 10.,  8.])
print(torch.add(a, b)) # tensor([10., 10.,  8.])

# Обычное вычитание
print(a.sub(b)) # tensor([-8., 4.,  -2.])
print(torch.sub(a, b)) # tensor([-8., 4.,  -2.])

# Обычное умножение
print(a.mul(b)) # tensor([9., 21.,  15.])
print(torch.mul(a, b)) # tensor([9., 21.,  15.])

# Обычное деление (/)
print(a.div(b)) # tensor([0.1111, 2.3333,  0.6000])
print(torch.div(a, b)) # tensor([0.1111, 2.3333,  0.6000])
# Отбрасывание дробной части
print(a.div(b, rounding_mode='trunc')) # tensor([0., 2.,  0.])
print(torch.div(a, b, rounding_mode='trunc')) # tensor([0., 2.,  0.])
# Округление в меньшую сторону
print(a.div(c, rounding_mode='floor')) # tensor([-1., -3.,  -1.])
print(torch.div(a, c, rounding_mode='floor')) # tensor([-1., -3.,  -1.])

# Знак результата зависит от делителя
print(c.remainder(a)) # tensor([-0., 4.,  1.])
print(torch.remainder(c, a)) # tensor([-0., 4.,  1.])
# Знак результата зависит от делимого
print(c.fmod(a)) # tensor([-0., -3., -2.])
print(torch.fmod(c, a)) # tensor([-0., -3.,  -2.])

# res и a ссылаются на одну и ту же память
res = b.add_(a) # tensor([10., 10.,  8.])

# res и a ссылаются на разную память
# b = tensor([11., 17., 11.]), res = tensor([ 9., 15.,  9.])
res = b.add_(a) - 2
```

#CS #Python #PyTorch #Тензоры 